---
layout: post
title: 父类与子类
tag: C++父类与子类
---
<p><strong>一、父类与子类</strong></p>

<h2>1.父类与子类的相互转换</h2>

<p>派生类的对象可以赋给基类，反之不行</p>

<p>基类的指针可以指向派生类，反之不行<br />
基类的引用可以初始化为派生类的对象，反之不行</p>

<p>派生类指针必须强制转换为基类指针后才可以指向基类</p>

<p>基类指针转换为派生类指针容易导致崩溃性错误</p>

<p>虚基类的引用或派生不能转换为派生类</p>


<p>&nbsp;</p>

<h2>2.继承关系对基类成员的影响</h2>

<table border="1" cellpadding="1" cellspacing="1" style="width:225px">
	<tbody>
		<tr>
			<td>&nbsp;</td>
			<td>公有成员</td>
			<td>保护成员</td>
			<td>私有成员</td>
		</tr>
		<tr>
			<td>公有继承</td>
			<td>公有</td>
			<td>保护</td>
			<td>不可访问</td>
		</tr>
		<tr>
			<td>保护继承</td>
			<td>保护</td>
			<td>保护</td>
			<td>不可访问</td>
		</tr>
		<tr>
			<td>私有继承</td>
			<td>私有</td>
			<td>私有</td>
			<td>不可访问</td>
		</tr>
		<tr>
			<td>成员函数</td>
			<td>1</td>
			<td>1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>对象</td>
			<td>1</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>子类</td>
			<td>1</td>
			<td>1</td>
			<td>0</td>
		</tr>
	</tbody>
</table>

<p>1：可以访问 0：不可访问</p>

<p>当所有成员都变成不可访问时，再往下派生就没有意义了</p>

<p><strong>二、子类的构造与析构</strong></p>

<p>1.构造派生类对象时，先执行基类的构造函数，再执行子类的构造函数，析构反之</p>

<p>&nbsp;</p>

<p>2.如果是多重继承，基类的构造顺序按给定的顺序，析构反之</p>


<p>3.利用基类的构造函数构造子类，效率更高</p>


<p><strong>三、多重继承</strong></p>

<p>1.多重继续的二义性，根本原因是</p>

<p>&nbsp;</p>

<p><img src="file:///C:/Users/liushuisheng/AppData/Local/youdao/ynote/images/62152C48CC58479186A6BAB3C35A137D/0_1326786263XRpI.gif.png" style="height:159px; width:161px" /></p>

<p>假如A有Test()，则B和C都有Test()，于是D产生了二义性</p>


<p><br />
2.编译器通常都是从离自己最近的目录树向上搜索的</p>

<p>子类的Test()覆盖了基类的Test()，并不代表基类的Test()消失，只是不能直接访问</p>


<p>3.对于单一继承，子类能否访问父类的父类，只与继承的方式有关</p>

<p>对于多重继承，子类不能直接访问父类的父类。</p>

<p>4.用virtual来避免二义性。</p>

<p>class B : virtual public A.</p>

<p>&nbsp;</p>

<p><strong>四、继承与包含</strong></p>

<p>1.一个类的成员变量列表中包含另一个类的对象，叫做包含（包容）。</p>

<p>&nbsp;</p>

<p>2.包含与私有继承的区别：</p>

<p>包含：</p>

<p>1）使程序看上去更清晰易懂</p>

<p>2）不存在继承带来的问题</p>

<p>3）可以包括另一个类的多个对象</p>

<p>私有继承：</p>

<p>1）可以访问基类的保护成员</p>

<p>2）可以重定义虚函数，实现多态</p>
